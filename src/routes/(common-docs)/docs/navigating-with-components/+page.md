---
title: Navigating With Components
description: Use Link components for seamless navigation in Svelte apps with automatic active state styling
---

This library only provides one component for navigation: The `Link` component. This is a Svelte component that generates an HTML anchor element users can click to perform navigation via the environment’s **History API**.

:::tip[HTML Anchor Elements May Also Work]
For hash routing scenarios, regular HTML anchor elements with an HREF that only contains a hash fragment (the HREF starts with the pound sign `#`), may work OK and may not require replacement. The one thing to have in mind is to be careful that the hash value is in accordance with the expectations of this routing library.

More information near the end.
:::

It is very simple to use, and more often than not, it should serve as a drop-in replacement for regular HTML anchor elements:

```svelte
<script lang="ts">
  import { Link } from "@svelte-router/core";

  const appLinks = [
    {
      text: 'home',
      href: '/',
    },
    {
      text: 'profile',
      href: '/profile',
    }
  ];
</script>

<nav>
  <ul>
    {#each appLinks as link (link.text)}
      <Link href={link.href}>{link.text}</Link>
    {/each}
  </ul>
</nav>
```

This would be the most basic usage for the `Link` component, where we provide the `href` property. The component, by virtue of the information around it, will internally use the `calculateHref()` function (see the [API Reference](/docs/api) and [Navigating with JavaScript](/docs/navigating-with-javascript) for information) to generate the final, appropriate URL for the routing universe specified via the `defaultHash` library option, as explained in the [Routing Modes](/docs/routing-modes) document.

Of course, if we wanted or needed to, we can also explicitly specify a routing universe by providing the `hash` property, just like we do with the rest of components that accept this property.

`Link` components may also be given a value (any *serializable* value) to be stored in the **History API** when navigating (when the generated anchor element is clicked/activated):

```svelte
<Link href="/some/path" state={{ flag: true }}>
  ...
</Link>
```

Whatever piece of data is passed to the state property will be available as history state once navigation happens.

The **History API** allows two forms of navigation: Pushing new URLs to the stack or replacing the URL at the top of the stack. By default, `Link` components push its HREF as a new URL, but we can specify the `replace` property to make it perform a replace operation instead.

We can also tell the `Link` component to preserve the current query string simply by specifying the `preserveQuery` property:

```svelte
<Link href="/some/path" replace preserveQuery>...</Link>
<Link href="/some/path" replace preserveQuery="debug">...</Link>
<Link href="/some/path" replace preserveQuery={['debug', 'fullscreen']}>...</Link>
```

This example creates 3 variations of the same `Link` component. All variations do a replace operation via the **History API**, as they all specify the `replace` property. The first one, however, will preserve the entirety of the current URL’s query string (a. k. a. search parameters); the second variant only preserves the search parameter named `"debug"`, if it exists; the third variant only preserves the `"debug"` and `"fullscreen"` search parameters, if they exist.

## Router-Driven Properties

Up to this point, everything we have seen will work with any and all `Link` component instances, regardless of where they are positioned in the HTML document. There are, however, 3 properties that can only work if the `Link` component instance is within the confines of a parent router: `prependBasePath`, `activeFor` and `activeState`.

We have learned that routers have a `basePath` property which is used to define common, always-present path segments. This allows us to write route paths (in `Route` components) without those path segments, therefore saving us time and effort, and enabling us to write applications and components that can be mounted in arbitrary URL paths.

Well, this ability is also available to `Link` components, but only on-demand using the `prependBasePath` property:

```svelte
<Router basePath="/base/path">
  <Link href="/some/where" prependBasePath>...</Link>
</Router>
```

Because the example `Link` component has a parent router with an established base path of `"/base/path"`, the resulting HREF created by the child `Link` component will be `"/base/path/some/where"`. It has inherited the parent router’s base path setting.

Then comes the `activeFor` property (and its companion property, `activeState`). This is used to automagically style the HTML anchor element generated by the `Link` component whenever a particular route matches.

Assuming the `"home"` and `"user-profile"` strings are the keys of two existing routes inside a router, let’s re-write the first example like this:

```svelte
<script lang="ts">
  import {
    Link,
    type ActiveState,
    type ActiveStateAriaAttributes
  } from "@svelte-router/core";
  import { userIsAdmin } from "./magical-tools.js";

  const aria = {
    current: 'page'
  } satisfies ActiveStateAriaAttributes;

  const appLinks: {
    text: string;
    href: string;
    activeFor: string;
    activeState: ActiveState;
  } = [
    {
      text: 'home',
      href: '/',
      activeFor: 'home',
      activeState: {
        class: 'active',
        aria,
      },
    },
    {
      text: 'profile',
      href: '/profile',
      activeFor: 'user-profile',
      activeState: {
        class: ['active', { 'active-admin': userIsAdmin()}]
        aria,
      },
    }
  ];
</script>

<nav>
  <ul>
    {#each appLinks as link (link.text)}
      <Link
        href={link.href}
        activeFor={link.activeFor}
        activeState={link.activeState}
      >
        {link.text}
      </Link>
    {/each}
  </ul>
</nav>
```

The classes, styles and attributes present in the value of the `activeState` property (`style` not actually present in the example) will be automatically applied to the HTML anchor element whenever the route identified by the given key (in the `activeFor` property) becomes active (is matched by the parent router).

### The `ActiveStateAriaAttributes` Type

This type simplifies all `aria-` attributes by removing the need to write `aria-` at the beginning. So, in the example above, when we write `const aria = { current: 'page' }`, we’re really adding the `aria-current` attribute to the list.

It is worth noticing that the value of `activeState.class` for the `home` route is much simpler than the one for the `user-profile` route. In case you are not noticing, both are values accepted by the `clsx` NPM package. Let’s remember that since Svelte **v5.16.0**, we can pass this kind of values around to class attributes, so we can go nuts and exploit its full potential.

:::info[The Barely-Mentioned ActiveState Properties]
Examine the `ActiveState` type for more information about the properties it defines. These are very simple.

The `class` property adds CSS classes to the HTML anchor element.

The `style` property adds inline styling to the HTML anchor element, and can be a string, or a record of CSS property/value pairs.

The `aria` property is a record that can be used to set any `aria-` property upon route activation.
:::

We have now covered all possible properties of the `Link` component. Let’s see what the `children` snippet has to offer:

```svelte
<Link href="/some/where">
  {#snippet children({ state, rs })}
    ...
  {/snippet}
</Link>
```

If needed, we can access the state data our application has been saving while navigating using the **History API**, and if the `Link` component is within the confines of a parent router, we can also access the parent router’s route status information (named `rs`). This can be used to gain knowledge of which routes are currently matching, and we can even read the route parameter values for routes that define them and are currently matching (`rs[<route key>].routeParams`).

## The Helper `LinkContext` Component

On larger applications with more than a couple navigation links, it can be tedious to set repeatedly a property like `preserveQuery`.

For the cases where we want the same property value on `Link` components for the `replace`, `prependBasePath`, `preserveQuery` and `activeState` properties, we may use a `LinkContext` component and set the desired values on this helper component instead. Any child `Link` components will inherit the properties, so long the properties are not defined locally in the `Link` component itself:

```svelte
<LinkContext preserveQuery={['debug', 'fullscreen']} prependBasePath>
  <Link href="...">...</Link>
  <Link href="...">...</Link>
  <Link href="...">...</Link>
  <Link href="...">...</Link>
  <Link href="...">...</Link>
  <Link href="...">...</Link>
  <Link
    href="/"
    activeState={{ key: 'home', class: 'active' }}
    preserveQuery={false}
  >
    Back to Homepage
  </Link>
  <Link href="...">...</Link>
</LinkContext>
```

In this example, all `Link` component instances will preserve the search parameters specified in the `LinkContext` component, except for the "Back to Homepage" link that explicitly states that search parameters must not be preserved. This link serves as a reset.

Since no links in the example explicitly define the value of `prependBasePath`, the inherited value from `LinkContext` will ensure the parent router’s `basePath` value is prepended to all HREFs for all `Link` component instances.

:::info[LinkContext is Routing-Universe-Unaware]
This is the only component in the library that doesn’t support the `hash` property, and therefore applies its property values to all `Link` components, regardless of their routing universe.
:::

## Routing with HTML Anchor Elements

At the beginning of the document, it was made clear that regular HTML anchor elements can successfully be used to perform navigation, so long this navigation is confined to hash routing universes.

Valid HREF examples for the single hash routing universe are `"#/"` and `"#/some/path"`. Valid HREF examples for multi hash routing universes are `"#p1=/;p2=/"` and `"#left=/orders/123;right=/orders/456"`.

No other format will work. As seen, one must ensure that the HREF contains the actual and desired values, and one must remember, when doing micro-frontends, that the current environment’s URL might contain named hash routing universes we don’t know about at development time.

Routing with regular HTML anchor elements is risky. Whenever possible, and especially when dealing with loosely coupled applications like micro-frontends, use the `calculateHref()` or `calculateMultiHashFragment()` functions to create well-formed HREFs.

:::caution[The One Gotcha: History State]
Navigating hash universes with regular HTML anchor elements will carry `null` history state values. This routing library **chooses** to ignore this value and instead, it makes sure the existing history state is preserved.

To preserve whatever current state existed before the HTML anchor navigation occurred, an extra call to the History API’s `replaceState()` is made.
:::
